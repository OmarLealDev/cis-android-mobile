<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CHAT_FIXES_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CHAT_FIXES_SUMMARY.md" />
              <option name="updatedContent" value="# Chat Issues Fixed - Implementation Summary&#10;&#10;## Issues Addressed&#10;&#10;### 1. ✅ Add an arrow icon to go back in the Message screen&#10;**Status: ALREADY IMPLEMENTED**&#10;- The ChatScreen already has a back arrow icon in the top app bar&#10;- Location: `ChatScreen.kt`, line 47-53&#10;- Uses `Icons.AutoMirrored.Filled.ArrowBack` with proper navigation&#10;&#10;### 2. ✅ Fix &quot;Usuario&quot; display issue in chat list&#10;**Problem**: When a patient sends the first message, the chat list shows &quot;Usuario&quot; instead of the professional's name until the professional responds.&#10;&#10;**Solution Implemented**:&#10;- **Modified**: `FirestoreChatRepository.kt`&#10;- **Added**: User name fetching logic in `getChatPreviewsFlow()` method&#10;- **Added**: `updateMissingParticipantNames()` method that fetches user names from all user collections (patients, professionals, admins)&#10;- **Added**: `fetchUserName()` method that searches across user collections to find the correct name&#10;- **Added**: Background coroutine to update chat documents with fetched names&#10;&#10;**How it works**:&#10;1. When creating ChatPreview objects, if a participant name is &quot;Usuario&quot;, it triggers background name fetching&#10;2. The system searches patients, professionals, and admins collections for the user's full name&#10;3. Once found, it updates the chat document with the correct participant name&#10;4. Future chat list loads will show the correct name&#10;&#10;### 3. ✅ Add Push Notifications when messages are sent&#10;**Solution Implemented**:&#10;&#10;**New Files Created**:&#10;- `NotificationRepository.kt` - Interface for notification operations&#10;- `FirestoreNotificationRepository.kt` - FCM token management and notification sending&#10;- `MessagingService.kt` - Firebase Cloud Messaging service&#10;- `FCMService.kt` - FCM token initialization helper&#10;- `NotificationInitializer.kt` - Service to initialize notifications on user login&#10;&#10;**Dependencies Added**:&#10;- `firebase-messaging-ktx` to `build.gradle.kts`&#10;- Required permissions in `AndroidManifest.xml`:&#10;  - `INTERNET`&#10;  - `WAKE_LOCK`&#10;  - `POST_NOTIFICATIONS` (Android 13+)&#10;&#10;**Service Registration**:&#10;- Added `MessagingService` to `AndroidManifest.xml`&#10;&#10;**Integration**:&#10;- **Modified**: `FirestoreChatRepository.kt` to accept `NotificationRepository`&#10;- **Modified**: `ChatViewModel.kt` to inject notification repository&#10;- **Enhanced**: `sendMessage()` method to trigger push notifications&#10;&#10;**How it works**:&#10;1. When user logs in, FCM token is saved to Firestore&#10;2. When a message is sent, the system:&#10;   - Saves the message to Firestore&#10;   - Updates chat metadata&#10;   - Fetches receiver's FCM token&#10;   - Triggers notification sending (currently logs for demo, needs backend for actual sending)&#10;&#10;## Technical Notes&#10;&#10;### Push Notification Limitations&#10;The current implementation logs notification details but doesn't actually send push notifications. To fully implement:&#10;1. **Backend Required**: Need a backend service with Firebase Admin SDK to send actual FCM messages&#10;2. **Token Management**: FCM tokens are stored in Firestore collection `fcm_tokens`&#10;3. **Security**: Actual notification sending should be done server-side for security&#10;&#10;### User Name Resolution&#10;- The system now proactively fetches missing user names and updates chat documents&#10;- This happens asynchronously to avoid blocking the UI&#10;- Names are cached in the chat document's `participantNames` map for future use&#10;&#10;### Error Handling&#10;- All new code includes proper error handling&#10;- Non-critical errors (like notification failures) don't crash the app&#10;- Graceful fallbacks for missing data&#10;&#10;## Files Modified/Created&#10;&#10;### Modified Files:&#10;1. `FirestoreChatRepository.kt`&#10;   - Added user name fetching logic&#10;   - Added notification integration&#10;   - Enhanced imports for user profile DTOs&#10;&#10;2. `ChatViewModel.kt`&#10;   - Added notification repository injection&#10;   - Updated constructor dependencies&#10;&#10;3. `build.gradle.kts`&#10;   - Added Firebase Messaging dependency&#10;&#10;4. `libs.versions.toml`&#10;   - Added Firebase Messaging library reference&#10;&#10;5. `AndroidManifest.xml`&#10;   - Added required permissions&#10;   - Registered MessagingService&#10;&#10;### New Files Created:&#10;1. `NotificationRepository.kt`&#10;2. `FirestoreNotificationRepository.kt`&#10;3. `MessagingService.kt`&#10;4. `FCMService.kt`&#10;5. `NotificationInitializer.kt`&#10;&#10;## Testing Status&#10;- ✅ Compilation successful&#10;- ✅ No blocking errors&#10;- ⚠️  Push notifications require backend implementation for full functionality&#10;- ✅ User name fetching implemented and ready for testing&#10;- ✅ Back arrow already working&#10;&#10;## Next Steps (Optional)&#10;1. Implement backend service for actual FCM message sending&#10;2. Add notification permission request flow for Android 13+&#10;3. Add user settings for notification preferences&#10;4. Test the user name fetching in different scenarios" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SERVER_SIDE_FCM_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SERVER_SIDE_FCM_GUIDE.md" />
              <option name="updatedContent" value="# Server-Side FCM Implementation Guide&#10;&#10;## WhatsApp-Like Notification Behavior&#10;&#10;This guide shows how to implement proper server-side FCM notifications for the chat feature with WhatsApp-like behavior where notifications are only shown when the user is not actively in that specific chat.&#10;&#10;## Backend Implementation (Node.js/Firebase Functions Example)&#10;&#10;```javascript&#10;const admin = require('firebase-admin');&#10;&#10;// Initialize Firebase Admin SDK&#10;admin.initializeApp({&#10;  credential: admin.credential.applicationDefault(),&#10;  // Your project config&#10;});&#10;&#10;/**&#10; * Send a chat message notification to a specific user&#10; * Only sends notification if the user should receive it based on client-side state&#10; */&#10;async function sendChatNotification(data) {&#10;  const {&#10;    receiverUserId,&#10;    senderId,&#10;    senderName,&#10;    messageContent,&#10;    chatId,&#10;    receiverToken&#10;  } = data;&#10;&#10;  const message = {&#10;    token: receiverToken,&#10;    data: {&#10;      chatId: chatId,&#10;      senderId: senderId,&#10;      senderName: senderName,&#10;      message: messageContent,&#10;      type: 'chat_message'&#10;    },&#10;    notification: {&#10;      title: senderName,&#10;      body: messageContent&#10;    },&#10;    android: {&#10;      priority: 'high',&#10;      notification: {&#10;        channelId: 'chat_messages',&#10;        priority: 'high',&#10;        defaultSound: true&#10;      }&#10;    },&#10;    apns: {&#10;      payload: {&#10;        aps: {&#10;          alert: {&#10;            title: senderName,&#10;            body: messageContent&#10;          },&#10;          sound: 'default',&#10;          badge: 1&#10;        }&#10;      }&#10;    }&#10;  };&#10;&#10;  try {&#10;    const response = await admin.messaging().send(message);&#10;    console.log('Successfully sent message:', response);&#10;    return response;&#10;  } catch (error) {&#10;    console.error('Error sending message:', error);&#10;    throw error;&#10;  }&#10;}&#10;&#10;/**&#10; * Cloud Function to handle message notifications&#10; */&#10;exports.sendMessageNotification = functions.firestore&#10;  .document('messages/{messageId}')&#10;  .onCreate(async (snap, context) =&gt; {&#10;    const message = snap.data();&#10;    const { chatId, senderId, senderName, content } = message;&#10;&#10;    try {&#10;      // Get chat participants&#10;      const chatDoc = await admin.firestore()&#10;        .collection('chats')&#10;        .doc(chatId)&#10;        .get();&#10;&#10;      if (!chatDoc.exists) {&#10;        console.error('Chat not found:', chatId);&#10;        return;&#10;      }&#10;&#10;      const chat = chatDoc.data();&#10;      const receiverId = chat.participantIds.find(id =&gt; id !== senderId);&#10;&#10;      if (!receiverId) {&#10;        console.error('Receiver not found for chat:', chatId);&#10;        return;&#10;      }&#10;&#10;      // Get receiver's FCM token&#10;      const tokenDoc = await admin.firestore()&#10;        .collection('fcm_tokens')&#10;        .doc(receiverId)&#10;        .get();&#10;&#10;      if (!tokenDoc.exists) {&#10;        console.log('No FCM token found for user:', receiverId);&#10;        return;&#10;      }&#10;&#10;      const receiverToken = tokenDoc.data().token;&#10;&#10;      // Send notification&#10;      await sendChatNotification({&#10;        receiverUserId: receiverId,&#10;        senderId: senderId,&#10;        senderName: senderName,&#10;        messageContent: content,&#10;        chatId: chatId,&#10;        receiverToken: receiverToken&#10;      });&#10;&#10;    } catch (error) {&#10;      console.error('Error in sendMessageNotification:', error);&#10;    }&#10;  });&#10;```&#10;&#10;## Key Features Implemented&#10;&#10;### 1. Client-Side Chat State Management&#10;- **ChatStateManager**: Tracks current chat state and app foreground/background status&#10;- **Notification Filtering**: Prevents notifications when user is in the active chat&#10;- **Lifecycle Tracking**: Properly handles app/chat entry and exit&#10;&#10;### 2. Proper Data Structure&#10;The FCM notification includes all necessary data:&#10;```json&#10;{&#10;  &quot;data&quot;: {&#10;    &quot;chatId&quot;: &quot;user1_user2&quot;,&#10;    &quot;senderId&quot;: &quot;user1&quot;,&#10;    &quot;senderName&quot;: &quot;John Doe&quot;,&#10;    &quot;message&quot;: &quot;Hello!&quot;,&#10;    &quot;type&quot;: &quot;chat_message&quot;&#10;  }&#10;}&#10;```&#10;&#10;### 3. Client-Side Logic&#10;- **Self-Message Filtering**: Prevents users from getting notifications for their own messages&#10;- **Active Chat Detection**: Only shows notifications when user is not in that specific chat&#10;- **App State Awareness**: Considers both app foreground state and specific chat activity&#10;&#10;### 4. WhatsApp-Like Behavior&#10;Notifications are shown when:&#10;- User is not in the app (background)&#10;- User is in the app but not in the specific chat that received the message&#10;- User is in a different chat&#10;&#10;Notifications are NOT shown when:&#10;- User sent the message themselves&#10;- User is actively viewing the chat that received the message&#10;&#10;## Implementation Checklist&#10;&#10;✅ ChatStateManager created and integrated  &#10;✅ MessagingService updated with proper filtering  &#10;✅ MainActivity tracks app lifecycle  &#10;✅ ChatScreen tracks chat entry/exit  &#10;✅ ChatListScreen resets chat state  &#10;✅ Notification data structure includes senderId  &#10;⏳ Server-side implementation (requires backend deployment)  &#10;&#10;## Next Steps&#10;&#10;1. **Deploy Backend**: Implement the server-side FCM sending using Firebase Functions or your backend service&#10;2. **Testing**: Test the notification behavior in different scenarios&#10;3. **Fine-tuning**: Adjust notification timing and content as needed&#10;&#10;The client-side implementation is now complete and will properly filter notifications based on user's current chat state, providing a WhatsApp-like experience." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/WHATSAPP_NOTIFICATION_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WHATSAPP_NOTIFICATION_IMPLEMENTATION.md" />
              <option name="updatedContent" value="# WhatsApp-Like Notification Implementation Summary&#10;&#10;## ✅ Problem Fixed&#10;&#10;The notification system now works like WhatsApp - notifications only appear when the user is NOT actively viewing that specific chat conversation.&#10;&#10;##  Changes Made&#10;&#10;### 1. Created ChatStateManager (/data/notification/ChatStateManager.kt)&#10;- Tracks current chat ID and app state&#10;- Determines when notifications should be shown&#10;- Provides WhatsApp-like behavior&#10;&#10;### 2. Updated MessagingService (/data/notification/MessagingService.kt)&#10;- Fixed compilation error (`launch` import issue)&#10;- Added self-notification filtering (users don't get notifications for their own messages)&#10;- Added chat state checking using ChatStateManager&#10;- Only shows notifications when user is not in that specific chat&#10;&#10;### 3. Updated MainActivity (/MainActivity.kt)&#10;- Added app lifecycle tracking (onResume/onPause)&#10;- Notifies ChatStateManager when app goes foreground/background&#10;&#10;### 4. Updated ChatScreen (/ui/feature/chat/chat/ChatScreen.kt)&#10;- Tracks when user enters/exits specific chats&#10;- Properly handles back button to exit chat state&#10;- Uses DisposableEffect for cleanup&#10;&#10;### 5. Updated ChatListScreen (/ui/feature/chat/chatList/ChatListScreen.kt)&#10;- Resets chat state when user enters chat list&#10;- Ensures no specific chat is marked as active&#10;&#10;### 6. Enhanced Notification Data Structure&#10;- Updated NotificationRepository interface to include senderId&#10;- Modified FirestoreNotificationRepository to pass sender information&#10;- Updated FirestoreChatRepository to include senderId in notifications&#10;&#10;##  Notification Behavior Now&#10;&#10;### ✅ Notifications WILL be shown when:&#10;- User is not in the app (background/closed)&#10;- User is in the app but viewing a different screen&#10;- User is in a different chat conversation&#10;- Another user sends a message&#10;&#10;### ❌ Notifications WON'T be shown when:&#10;- User sends a message themselves&#10;- User is actively viewing the chat that received the message&#10;- User is currently typing in that specific chat&#10;&#10;##  How It Works&#10;&#10;1. **App Lifecycle**: MainActivity tracks when app goes foreground/background&#10;2. **Chat State**: ChatScreen tracks when user enters/exits specific chats&#10;3. **Message Reception**: MessagingService checks both conditions before showing notifications&#10;4. **Smart Filtering**: Uses chat ID and sender ID to make intelligent decisions&#10;&#10;##  Testing Scenarios&#10;&#10;To test the implementation:&#10;&#10;1. **Background Notifications**: Close/minimize app → Send message → Should receive notification&#10;2. **Different Chat**: Open Chat A → Send message to Chat B → Should receive notification  &#10;3. **Same Chat**: Open Chat A → Send message to Chat A → Should NOT receive notification&#10;4. **Self Messages**: Send message yourself → Should NOT receive notification&#10;5. **Chat List**: Be in chat list → Send message to any chat → Should receive notification&#10;&#10;##  Notes&#10;&#10;- The back arrow navigation issue has been addressed by properly handling chat state in the back button click&#10;- Server-side implementation guide has been provided in `SERVER_SIDE_FCM_GUIDE.md`&#10;- All compilation errors have been fixed&#10;- The implementation is ready for testing&#10;&#10;##  Next Steps&#10;&#10;1. Test the notification behavior in different scenarios&#10;2. Implement the server-side FCM sending using the provided guide&#10;3. Fine-tune notification timing if needed&#10;4. Add any additional notification customization (sound, vibration, etc.)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/cis_ac/cis_ac/data/admin/FirestoreAdminRequestsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/cis_ac/cis_ac/data/admin/FirestoreAdminRequestsRepository.kt" />
              <option name="originalContent" value="package com.cis_ac.cis_ac.data.admin&#10;&#10;import com.cis_ac.cis_ac.core.Result&#10;import com.cis_ac.cis_ac.core.model.Discipline&#10;import com.cis_ac.cis_ac.core.model.Gender&#10;import com.cis_ac.cis_ac.core.model.Modality&#10;import com.cis_ac.cis_ac.core.model.Population&#10;import com.cis_ac.cis_ac.core.model.Professional&#10;import com.cis_ac.cis_ac.core.model.Sessions&#10;import com.cis_ac.cis_ac.core.model.UserRole&#10;import com.cis_ac.cis_ac.data.userprofile.dto.ProfessionalFS&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObject&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class FirestoreAdminRequestsRepository(&#10;    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;) : AdminRequestsRepository {&#10;&#10;    private val pros = db.collection(&quot;professionals&quot;)&#10;&#10;    override fun watchPendingProfessionals(): Flow&lt;Result&lt;List&lt;Professional&gt;&gt;&gt; = callbackFlow {&#10;        trySend(Result.Loading)&#10;&#10;        val reg = pros.whereEqualTo(&quot;verified&quot;, false)&#10;            .addSnapshotListener { snap, err -&gt;&#10;                if (err != null) {&#10;                    trySend(Result.Error(err.message ?: &quot;Error al cargar solicitudes&quot;, err))&#10;                    return@addSnapshotListener&#10;                }&#10;                val list = snap?.documents?.mapNotNull { d -&gt;&#10;                    d.toObject&lt;ProfessionalFS&gt;()?.toDomain()&#10;                }.orEmpty()&#10;                trySend(Result.Success(list))&#10;            }&#10;&#10;        awaitClose { reg.remove() }&#10;    }&#10;&#10;    override suspend fun getProfessional(uid: String): Result&lt;Professional&gt; = try {&#10;        val snap = pros.document(uid).get().await()&#10;        val dto = snap.toObject&lt;ProfessionalFS&gt;()&#10;        val pro = dto?.toDomain() ?: return Result.Error(&quot;No se encontró la solicitud&quot;)&#10;        Result.Success(pro)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al obtener solicitud&quot;, e)&#10;    }&#10;&#10;    override suspend fun approve(uid: String): Result&lt;Unit&gt; = try {&#10;        pros.document(uid).update(mapOf(&quot;verified&quot; to true, &quot;active&quot; to true)).await()&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al aprobar&quot;, e)&#10;    }&#10;&#10;    override suspend fun reject(uid: String): Result&lt;Unit&gt; = try {&#10;        // Política simple: asegurar flags en falso. (Si prefieres borrar el doc, usa .delete().await())&#10;        pros.document(uid).update(mapOf(&quot;verified&quot; to false, &quot;active&quot; to false)).await()&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al rechazar&quot;, e)&#10;    }&#10;&#10;    private fun ProfessionalFS.toDomain(): Professional? {&#10;        val uid = this.uid ?: return null&#10;        val email = this.email ?: return null&#10;&#10;        val roleEnum = runCatching { UserRole.valueOf(this.role ?: &quot;UNDEFINED&quot;) }&#10;            .getOrDefault(UserRole.UNDEFINED)&#10;&#10;        val genderEnum = runCatching { Gender.valueOf(this.gender ?: Gender.Unspecified.name) }&#10;            .getOrDefault(Gender.Unspecified)&#10;&#10;        val disciplineEnum = runCatching {&#10;            Discipline.valueOf(this.mainDiscipline ?: Discipline.PSYCHOLOGY.name)&#10;        }.getOrDefault(Discipline.PSYCHOLOGY)&#10;&#10;        val topicsStr = this.topics ?: &quot;&quot;&#10;&#10;        // IDs (List&lt;Int&gt;?) → enums (Set&lt;Enum&gt;)&#10;        val modalitiesSet: Set&lt;Modality&gt; =&#10;            (this.modalities ?: emptyList()).map { i: Int -&gt; Modality.fromInt(i) }.toSet()&#10;        val sessionsSet: Set&lt;Sessions&gt; =&#10;            (this.sessionTypes ?: emptyList()).map { i: Int -&gt; Sessions.fromInt(i) }.toSet()&#10;        val populationsSet: Set&lt;Population&gt; =&#10;            (this.populations ?: emptyList()).map { i: Int -&gt; Population.fromInt(i) }.toSet()&#10;&#10;        // schedule: prioriza scheduleInt; de lo contrario convierte schedule&#10;        val scheduleIntMap: Map&lt;Int, List&lt;Int&gt;&gt; = when {&#10;            this.scheduleInt != null -&gt; this.scheduleInt!!&#10;            this.schedule != null -&gt; this.schedule!!.mapNotNull { (k, v) -&gt;&#10;                val day = k.toIntOrNull() ?: return@mapNotNull null&#10;                day to v.map { it.toInt() }&#10;            }.toMap()&#10;            else -&gt; emptyMap()&#10;        }&#10;&#10;        return Professional(&#10;            uid = uid,&#10;            email = email,&#10;            role = roleEnum,&#10;            fullName = this.fullName.orEmpty(),&#10;            phone = this.phone.orEmpty(),&#10;            dob = this.dob.orEmpty(),&#10;            gender = genderEnum,&#10;            licenseNumber = this.licenseNumber.orEmpty(),&#10;            verified = this.verified ?: false,&#10;            active = this.active ?: false,&#10;            mainDiscipline = disciplineEnum,&#10;            cvUrl = this.cvUrl,&#10;            licenseUrl = this.licenseUrl,&#10;&#10;            speciality = this.speciality.orEmpty(),&#10;            approach   = this.approach,&#10;            topics     = topicsStr,&#10;            expertiz   = this.expertiz.orEmpty(),&#10;&#10;            // ⬇️ dominio = enums&#10;            modalities   = modalitiesSet,&#10;            sessionTypes = sessionsSet,&#10;            populations  = populationsSet,&#10;&#10;            schedule  = scheduleIntMap,&#10;            semblance = this.semblance.orEmpty(),&#10;            createdAt = this.createdAt&#10;        )&#10;    }&#10;&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.cis_ac.cis_ac.data.admin&#10;&#10;import com.cis_ac.cis_ac.core.Result&#10;import com.cis_ac.cis_ac.core.model.Discipline&#10;import com.cis_ac.cis_ac.core.model.Gender&#10;import com.cis_ac.cis_ac.core.model.Modality&#10;import com.cis_ac.cis_ac.core.model.Population&#10;import com.cis_ac.cis_ac.core.model.Professional&#10;import com.cis_ac.cis_ac.core.model.Sessions&#10;import com.cis_ac.cis_ac.core.model.UserRole&#10;import com.cis_ac.cis_ac.data.userprofile.dto.ProfessionalFS&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObject&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class FirestoreAdminRequestsRepository(&#10;    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;) : AdminRequestsRepository {&#10;&#10;    private val pros = db.collection(&quot;professionals&quot;)&#10;&#10;    override fun watchPendingProfessionals(): Flow&lt;Result&lt;List&lt;Professional&gt;&gt;&gt; = callbackFlow {&#10;        trySend(Result.Loading)&#10;&#10;        val reg = pros.whereEqualTo(&quot;verified&quot;, false)&#10;            .addSnapshotListener { snap, err -&gt;&#10;                if (err != null) {&#10;                    trySend(Result.Error(err.message ?: &quot;Error al cargar solicitudes&quot;, err))&#10;                    return@addSnapshotListener&#10;                }&#10;                val list = snap?.documents?.mapNotNull { d -&gt;&#10;                    d.toObject&lt;ProfessionalFS&gt;()?.toDomain()&#10;                }.orEmpty()&#10;                trySend(Result.Success(list))&#10;            }&#10;&#10;        awaitClose { reg.remove() }&#10;    }&#10;&#10;    override suspend fun getProfessional(uid: String): Result&lt;Professional&gt; = try {&#10;        val snap = pros.document(uid).get().await()&#10;        val dto = snap.toObject&lt;ProfessionalFS&gt;()&#10;        val pro = dto?.toDomain() ?: return Result.Error(&quot;No se encontró la solicitud&quot;)&#10;        Result.Success(pro)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al obtener solicitud&quot;, e)&#10;    }&#10;&#10;    override suspend fun approve(uid: String): Result&lt;Unit&gt; = try {&#10;        pros.document(uid).update(mapOf(&quot;verified&quot; to true, &quot;active&quot; to true)).await()&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al aprobar&quot;, e)&#10;    }&#10;&#10;    override suspend fun reject(uid: String): Result&lt;Unit&gt; = try {&#10;        // Política simple: asegurar flags en falso. (Si prefieres borrar el doc, usa .delete().await())&#10;        pros.document(uid).update(mapOf(&quot;verified&quot; to false, &quot;active&quot; to false)).await()&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e.message ?: &quot;Error al rechazar&quot;, e)&#10;    }&#10;&#10;    private fun ProfessionalFS.toDomain(): Professional? {&#10;        val uid = this.uid ?: return null&#10;        val email = this.email ?: return null&#10;&#10;        val roleEnum = runCatching { UserRole.valueOf(this.role ?: &quot;UNDEFINED&quot;) }&#10;            .getOrDefault(UserRole.UNDEFINED)&#10;&#10;        val genderEnum = runCatching { Gender.valueOf(this.gender ?: Gender.Unspecified.name) }&#10;            .getOrDefault(Gender.Unspecified)&#10;&#10;        val disciplineEnum = runCatching {&#10;            Discipline.valueOf(this.mainDiscipline ?: Discipline.PSYCHOLOGY.name)&#10;        }.getOrDefault(Discipline.PSYCHOLOGY)&#10;&#10;        val topicsStr = this.topics ?: &quot;&quot;&#10;&#10;        // IDs (List&lt;Int&gt;?) → enums (Set&lt;Enum&gt;)&#10;        val modalitiesSet: Set&lt;Modality&gt; =&#10;            (this.modalities ?: emptyList()).map { i: Int -&gt; Modality.fromInt(i) }.toSet()&#10;        val sessionsSet: Set&lt;Sessions&gt; =&#10;            (this.sessionTypes ?: emptyList()).map { i: Int -&gt; Sessions.fromInt(i) }.toSet()&#10;        val populationsSet: Set&lt;Population&gt; =&#10;            (this.populations ?: emptyList()).map { i: Int -&gt; Population.fromInt(i) }.toSet()&#10;&#10;        // schedule: prioriza scheduleInt; de lo contrario convierte schedule&#10;        val scheduleIntMap: Map&lt;Int, List&lt;Int&gt;&gt; = when {&#10;            this.scheduleInt != null -&gt; this.scheduleInt!!&#10;            this.schedule != null -&gt; this.schedule!!.mapNotNull { (k, v) -&gt;&#10;                val day = k.toIntOrNull() ?: return@mapNotNull null&#10;                day to v.map { it.toInt() }&#10;            }.toMap()&#10;            else -&gt; emptyMap()&#10;        }&#10;&#10;        return Professional(&#10;            uid = uid,&#10;            email = email,&#10;            role = roleEnum,&#10;            fullName = this.fullName.orEmpty(),&#10;            phone = this.phone.orEmpty(),&#10;            dob = this.dob.orEmpty(),&#10;            gender = genderEnum,&#10;            licenseNumber = this.licenseNumber.orEmpty(),&#10;            verified = this.verified ?: false,&#10;            active = this.active ?: false,&#10;            mainDiscipline = disciplineEnum,&#10;            cvUrl = this.cvUrl,&#10;            licenseUrl = this.licenseUrl,&#10;&#10;            speciality = this.speciality.orEmpty(),&#10;            approach   = this.approach,&#10;            topics     = topicsStr,&#10;            expertiz   = this.expertiz.orEmpty(),&#10;&#10;            // ⬇️ dominio = enums&#10;            modalities   = modalitiesSet,&#10;            sessionTypes = sessionsSet,&#10;            populations  = populationsSet,&#10;&#10;            schedule  = scheduleIntMap,&#10;            semblance = this.semblance.orEmpty(),&#10;            createdAt = this.createdAt&#10;        )&#10;    }&#10;&#10;&#10;&#10;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>